<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <script type="text/javascript" src="./vue.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  <link rel="stylesheet" href="styles.css">

  <title>006 - List Rendering - Vue website tutorial</title>
</head>
<body>

  <a href="https://vuejs.org/v2/guide/list.html"><h3>Source</h3></a>

  <h1>6 - List Rendering</h1>
  <div id="listRendering1">
    <h2>Mapping an array of elements with <code>v-for</code> </h2>
    <p>
      The <code>v-for</code> directive can be used to access lists of data that
      are included in an array. The syntax that is used it in the form of
      <code>item in items</code>, where <code>items</code> is the data source property
      that is evaluated and <code>item</code> represents each one of the elements
      in that data source to be iterated.
    </p>

    <div class="jumbotron">
      <h4>Example</h4>
      <p>
        In the following example, there are two elements that are extracted from the
        data source property.
      </p>
      <code>
        <pre>
    data: {
      items: [
        {message: "Foo"},
        {message: "Bar"}
      ]
    }
        </pre>
      </code>
      <p>
        In order to render the <code>items</code> array, the v-for directive is
        used to iterate through.
      </p>
      <code>
        <pre>
    &lt;ul&gt;
      &lt;li v-for="item in items"&gt;{ {item.message} }&lt;/li&gt;
    &lt;/ul&gt;
        </pre>
      </code>

      <ul>
        <li v-for="item in items">{{item.message}}</li>
      </ul>
    </div>
  </div>

  <script type="text/javascript">
  var listRendering1 = new Vue ({
    el: "#listRendering1",
    data: {
      items: [
        {message: "Foo"},
        {message: "Bar"}
      ]
    }
  });
  </script>




  <div id="listRendering2">
    <p>
      An advantage that <code>v-for</code> has is that it allows us to also access
      other properties that are inside the <code>data</code> property.
    </p>
    <p>
      <code>v-for</code> also contains an additional argument that helps us access
      the index of the element in the array.
    </p>

    <div class="jumbotron">
      <h4>Example</h4>
      <p>
        In the following example, the second attribute is used in order to access
        the indeses of the array that is used in the <code>v-for</code> loop.
      </p>

      <code>
        <pre>
data: {
  parentMessage: "Parent",
  items: [
    {message: "Foo"},
    {message: "Bar"}
  ]
}
        </pre>
      </code>

      <p>
        The <code>v-for</code> code in the <code>li</code> tag is structured
        like this: <code>v-for="(item, index) in items"</code>
      </p>

      <ul>
        <li v-for="(item, index) in items">
          parentMessage: {{parentMessage}}, index: {{index}}, item.message: {{item.message}}
        </li>
      </ul>
    </div>

    <p>
      Also the <code>of</code> delimiter can be used. That helps so that the
      <code>v-for</code> look is closer to the JavaScript syntax.
     </p>
     <code>v-for="item of items"</code>

  </div>


  <script type="text/javascript">
  var listRendering2 = new Vue ({
    el: "#listRendering2",
    data: {
      parentMessage: "This is the parentMessage",
      items: [
        {message: "Foo"},
        {message: "Bar"}
      ]
    }
  });

  </script>









  <h2><code>v-for</code> with an Object</h2>
  <div id="listRendering3">
    <p>
      the <code>v-for</code> directive can also be used to iterate through
      objects. Contrary to the <code>for (var key in obj)</code> loop in vanilla
      JavaScript where in order to access the value of the property we have to type
      <code>obj[key]</code>, the defined variable in <code>v-for</code> returns
      the value and not just the key of each property in the object.
    </p>

    <div class="jumbotron">
      <h4>Example</h4>
      <p>
        In the following example, we are accessing the <code>userObj</code> properties
        values by defining a <code>user</code> variable in the <code>v-for</code>
        string.
      </p>
  <code>
    <pre>
  &lt;ul&gt;
    &lt;li v-for="property in userObj"&gt;{ {property} }&lt;/li&gt;
  &lt;/ul&gt;
    </pre>
  </code>

  <code>
    <pre>
      new Vue ({
        el: "#listRendering3",
        data: {
          userObj: {
            name: "Paraskevas",
            surname: "Apostolopoulos",
            address: "111 Main St."
          }
        }
      });
    </pre>
  </code>

      <ul>
        <li v-for="property in userObj">{{property}}</li>
      </ul>

      <p>
        If we would need to access the <code>key</code> of each obj, then we could
        add a second argument for accessing the key, and another one for the indexes.
      </p>
      <code>
        <pre>
      &lt;ul&gt;
        &lt;li v-for="property, key, index in userObj"&gt;{ {index + 1} }. { {key} }: { {property} }&lt;/li&gt;
      &lt;/ul&gt;
        </pre>
      </code>

      <ul>
        <li v-for="property, key, index in userObj">{{index + 1}}. {{key}}: {{property}}</li>
      </ul>
    </div>

    <p>
      Remember: When iterating through an object, the order of the keys in not guaranteed
      to be consistent through different JavaScript engines.
    </p>
  </div>

  <script type="text/javascript">
  var listRendering3 = new Vue ({
    el: "#listRendering3",
    data: {
      userObj: {
        name: "Paraskevas",
        surname: "Apostolopoulos",
        address: "111 Main St."
      }
    }
  });
  </script>




  <h3><code>key</code></h3>
  <p>
    When the elements at <code>v-for</code> get updated, Vue uses a way of patching
    the new elements to the DOM instead of updating the whole DOM's order and the
    appropriate index position.
  </p>
  <p>
    In order for Vue to be able to track each node's identity, we can use the <code>key</code>
    attribute. An ideal value for <code>key</code> can be the the <code>id</code>
    of each element.
  </p>
  <p>
    It is recommended that a <code>key</code> attribute is binded every time a
    <code>v-for</code> directive is being used.
  </p>


  <h2>Array change detection</h2>
  <div id="listRendering4">
    <h3>Mutation methods</h3>
    <p>
      Vue wraps the array mutation methods so that there can be a live update
      when these methods are used. The methods that can be used are:
    </p>
    <code>
      <ul>
        <li>push()</li>
        <li>pop()</li>
        <li>shift()</li>
        <li>unshift()</li>
        <li>unshift()</li>
        <li>splice()</li>
        <li>sort()</li>
        <li>reverse()</li>
      </ul>
    </code>
    <p>
      The advantage of Vue is that when a method is run, the DOM does not update the
      full array. What happens instead is that the elements of the array that are still
      used remain and new elements are added - or patched - instead.
    </p>


    <div class="jumbotron">
      <h4>Example</h4>
      <h5><code>.push()</code></h5>
      <p>
        Enter a new name in the <code>input</code> tag and hit enter. You will see
        that the <code>v-for</code> list gets updated from <code>.push()</code>.
        <code>
          v-on:keydown.enter="$event.target.value === '' ? null : students.push({name: $event.target.value});"
        </code>
      </p>
      <input type="text"
      v-on:keydown.enter="$event.target.value === '' ? null : students.push({name: $event.target.value});"
      v-on:keyup.enter="$event.target.value = ''">
      <ul>
        <li style="list-style: none" v-for="(student, index) in students" :key="index">{{index + 1}}: {{student.name}}</li>
      </ul>
      <h5><code>.reverse(), .sort()</code></h5>
      <p>
        For <code>.reverse()</code>, the code used was:
        <code>v-on:click="students.reverse()"</code>
      </p>
      <button type="button" v-on:click="students.reverse()">Reverse the list</button>
      <p>
        For <code>.sort()</code>, the code used was:
        <code>
          v-on:click="students.sort(function(a,b){return a.name.charCodeAt(0) - b.name.charCodeAt(0);})
        </code>
      </p>
      <button type="button"
      v-on:click="students.sort(function(a,b){return a.name.charCodeAt(0) - b.name.charCodeAt(0);})">
        Sort the list
      </button>
    </div>
    <h3>Non mutating methods / Replacing an array</h3>
    <p>
      The methods <code>.filter() .concat() .slice()</code> are non mutating methods.
      These methods always return a new array instead. When working with non
      mutating methods, we can replace the old array with a new one.
    </p>
    <p>
      For example, regular JavaScript, the <code>.filter()</code> method creates a new Array
      based on which elements pass the condition that is included in the callback
      function. Yet, Vue maintains the existing DOM array elements but it rather
      creates overlapping objects that constitute the new array.
    </p>
    <div class="jumbotron">
      <h4>Example</h4>
      <ul>
        <li v-for="student in students">{{student.name}}</li>
      </ul>
      <input type="text" v-on:keyup.enter="filterIt($event)">
      <p>
        You can filter the list of names by entering some letters in the <code>input</code>
        tag and hitting enter. The <code>filter()</code> method will filter out
        the array that is being iterated in the list above.
      </p>
      <code>
        <pre>
          methods: {
            filterIt: function(event) {
              this.students = this.students.filter(function(el) {
                return el.name.includes(event.target.value);
              });
              event.target.value = "";
            }
          }
        </pre>
      </code>
    </div>
    <h5>Note from me</h5>
    <p>
      Since the methods <code>concat() slice() and filter()</code> are returning
      a new array, there is no way to revert back to the original array.
    </p>



    <h3>Caveats</h3>
    <p>
      Due to limitations in JavaScript, Vue cannot detect certain changes in an
      array. In particular:
    </p>
    <ol>
      <li>When we try to change the value of each element directly: <br>
        <code>
          <pre>
            var vm = new Vue({
              data: {
                items: ['a', 'b', 'c']
              }
            });

            vm.items[1] = 'x';
            <span style="color: gray;">// is NOT reactive. The value in index 1 will not change.</span>
            vm.items.length = 2
            <span style="color: gray;">// is NOT reactive. The length of the array will not change.</span>
          </pre>
        </code>
      </li>
    </ol>

    <p>
      A way to overcome the challenge of changing the values of individual elements
      in the array is by:
    </p>
    <ul>
      <li>
        Using the <code>.splice()</code> method. <br>
        <code>vm.items.splice(indexOfItem, 1, newValue)</code>
      </li>
      <li>
        Using the <code>Vue.set()</code> method in the Vue constructor <br>
        <code>Vue.set(vm.items, indexOfItem, newValue)</code>
      </li>
    </ul>
    <p>
      A way to overcome the challenge of not being able to modify the length of the array,
      we can use <code>splice()</code>. <br>
      <code>vm.items.splice(newLength)</code>
    </p>

    <div class="jumbotron">
      <h4>Example - <code>splice(indexOfItem, 1, newValue)</code> </h4>
      <p>
        Select from the drop down menu which position you would like the new entry
        to be placed at. Then enter a name in the <code>input</code> tag and press
        enter. The <code>.splice()</code> method will update the array.
      </p>

      <ul>
        <li v-for="student in students">{{student.name}}</li>
      </ul>
      <div class="divSpliceArray">
        <h6>Before which position do you want to enter a new name?</h6>
        <select class="" name="">
          <option v-for="student in students" v-bind:value="student.name">Before {{student.name}}</option>
        </select>
        <h6>How many names should be removed?</h6>
        <select class="" name="">
          <option v-for="(student, idx) in students" v-bind:value="idx">{{idx}} names</option>
        </select>
        <h6>What is the new name?</h6>
        <input type="text" name="" value="" v-on:keydown.enter="spliceMe($event)">
      </div>
      <code>
        <pre>
  spliceMe: function(event) {
    if (event.target.value === "") return;

    var dropDownValue = event.path[1].children[1].value;
    var removalOfElements = event.path[1].children[3].value
    var newValue = event.target.value;

    for (var i = 0; i < this.students.length; i++) {
      if (this.students[i].name === dropDownValue){
        this.students.splice(i, removalOfElements, {name: newValue});
        event.target.value = ""
        break;
      }
    }
  }
        </pre>
      </code>
    </div>

    <div class="jumbotron">
      <h4>Example - <code>Vue.set(vm.items, indexOfItem, newValue)</code> </h4>
      <p>
        Same like above, use the drop down menus and the <code>input</code> tag.
      </p>

      <ul>
        <li v-for="student in students">{{student.name}}</li>
      </ul>
      <div class="divVueSetArray">
        <h6>Which name do you want to replace?</h6>
        <select class="" name="">
          <option v-for="(student, idx) in students" :value="student.name">
            {{student.name}}
          </option>
        </select>
        <h6>What is the new name?</h6>
        <input type="text" name="" value="" v-on:keydown.enter="vueSet($event)">
      </div>
      <code>
        <pre>
  vueSet: function(event) {
    if (event.target.value === "") return;
    var dropDownValue = event.path[1].children[1].value;

    for (var i = 0; i < this.students.length; i++) {
      if (this.students[i].name === dropDownValue){
        Vue.set(this.students, i, {name: event.target.value});
        event.target.value = "";
        break;
      }
    }
  }
        </pre>
      </code>

    </div>
  </div>


    <script>
    var listRendering4 = new Vue({
      el: "#listRendering4",
      data: {
        students: [
          {name: "Steve"},
          {name: "Angela"},
          {name: "Simon"},
          {name: "George"},
          {name: "Lisa"}
        ]
      },
      methods: {
        filterIt: function(event) {
          this.students = this.students.filter(function(el) {
            return el.name.includes(event.target.value);
          });
          event.target.value = "";
        },
        spliceMe: function(event) {
          if (event.target.value === "") return;
          //Variables that get the values the user selects in the drop down menus.
          var dropDownValue = event.path[1].children[1].value;
          var removalOfElements = event.path[1].children[3].value
          //Input tag value
          var newValue = event.target.value;
          /*
          make a for loop that iterates through students
          if the element[idx].name === dropDownValue
          Then do the splice
          */

          for (var i = 0; i < this.students.length; i++) {
            if (this.students[i].name === dropDownValue){
              this.students.splice(i, removalOfElements, {name: newValue});
              event.target.value = ""
              break;
            }
          }
        }, //End of spliceMe
        vueSet: function(event) {
          if (event.target.value === "") return;
          var dropDownValue = event.path[1].children[1].value;

          for (var i = 0; i < this.students.length; i++) {
            if (this.students[i].name === dropDownValue){
              Vue.set(this.students, i, {name: event.target.value});
              event.target.value = "";
              break;
            }
          }
        } //end of vueSet
      } //End of methods
    });

    </script>






    <h2>Object change detection caveats</h2>
    <div id="listRendering5">
      <p>
        Due to limitations in JavaScript, Vue cannot add any new REACTIVE
        properties in the data objects if they have not been previously declared
        in the Vue constructor.
        Hence: <br>
        <code>
          <pre>
  var vm = new Vue({
    data: {
      a: 1
    }
  })
  <span style="color: gray;">// `vm.a` is now reactive</span>

  vm.b = 2
  <span style="color: gray;">// `vm.b` is NOT reactive</span>
          </pre>
        </code>
      </p>

      <div class="jumbotron">
        <ul>
          <li v-for="(user, key) in userProfile">{{key}}: {{user}}</li>
        </ul>
      </div>

    </div>



    <script>
      var listRendering5 = new Vue({
        el: "#listRendering5",
        data: {
          userProfile: {
            name: "Paraskevas"
          }
        }
      });
    </script>












<a href="./005.html">Previous - Conditional Rendering</a> <a href="./007.html">Next - Event handling</a>

</body>
</html>
