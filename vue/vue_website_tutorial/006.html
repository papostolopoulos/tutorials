<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <script type="text/javascript" src="./vue.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  <link rel="stylesheet" href="styles.css">

  <title>006 - List Rendering - Vue website tutorial</title>
</head>
<body>

  <a href="https://vuejs.org/v2/guide/list.html"><h3>Source</h3></a>

  <h1>6 - List Rendering</h1>
  <div id="listRendering1">
    <h2>Mapping an array of elements with <code>v-for</code> </h2>
    <p>
      The <code>v-for</code> directive can be used to access lists of data that
      are included in an array. The syntax that is used it in the form of
      <code>item in items</code>, where <code>items</code> is the data source property
      that is evaluated and <code>item</code> represents each one of the elements
      in that data source to be iterated.
    </p>

    <div class="jumbotron">
      <h4>Example</h4>
      <p>
        In the following example, there are two elements that are extracted from the
        data source property.
      </p>
      <code>
        <pre>
    data: {
      items: [
        {message: "Foo"},
        {message: "Bar"}
      ]
    }
        </pre>
      </code>
      <p>
        In order to render the <code>items</code> array, the v-for directive is
        used to iterate through.
      </p>
      <code>
        <pre>
    &lt;ul&gt;
      &lt;li v-for="item in items"&gt;{ {item.message} }&lt;/li&gt;
    &lt;/ul&gt;
        </pre>
      </code>

      <ul>
        <li v-for="item in items">{{item.message}}</li>
      </ul>
    </div>
  </div>

  <script type="text/javascript">
  var listRendering1 = new Vue ({
    el: "#listRendering1",
    data: {
      items: [
        {message: "Foo"},
        {message: "Bar"}
      ]
    }
  });
  </script>




  <div id="listRendering2">
    <p>
      An advantage that <code>v-for</code> has is that it allows us to also access
      other properties that are inside the <code>data</code> property.
    </p>
    <p>
      <code>v-for</code> also contains an additional argument that helps us access
      the index of the element in the array.
    </p>

    <div class="jumbotron">
      <h4>Example</h4>
      <p>
        In the following example, the second attribute is used in order to access
        the indeses of the array that is used in the <code>v-for</code> loop.
      </p>

      <code>
        <pre>
data: {
  parentMessage: "Parent",
  items: [
    {message: "Foo"},
    {message: "Bar"}
  ]
}
        </pre>
      </code>

      <p>
        The <code>v-for</code> code in the <code>li</code> tag is structured
        like this: <code>v-for="(item, index) in items"</code>
      </p>

      <ul>
        <li v-for="(item, index) in items">
          parentMessage: {{parentMessage}}, index: {{index}}, item.message: {{item.message}}
        </li>
      </ul>
    </div>

    <p>
      Also the <code>of</code> delimiter can be used. That helps so that the
      <code>v-for</code> look is closer to the JavaScript syntax.
     </p>
     <code>v-for="item of items"</code>

  </div>


  <script type="text/javascript">
  var listRendering2 = new Vue ({
    el: "#listRendering2",
    data: {
      parentMessage: "This is the parentMessage",
      items: [
        {message: "Foo"},
        {message: "Bar"}
      ]
    }
  });

  </script>









  <h2><code>v-for</code> with an Object</h2>
  <div id="listRendering3">
    <p>
      the <code>v-for</code> directive can also be used to iterate through
      objects. Contrary to the <code>for (var key in obj)</code> loop in vanilla
      JavaScript where in order to access the value of the property we have to type
      <code>obj[key]</code>, the defined variable in <code>v-for</code> returns
      the value and not just the key of each property in the object.
    </p>

    <div class="jumbotron">
      <h4>Example</h4>
      <p>
        In the following example, we are accessing the <code>userObj</code> properties
        values by defining a <code>user</code> variable in the <code>v-for</code>
        string.
      </p>
  <code>
    <pre>
  &lt;ul&gt;
    &lt;li v-for="property in userObj"&gt;{ {property} }&lt;/li&gt;
  &lt;/ul&gt;
    </pre>
  </code>

  <code>
    <pre>
      new Vue ({
        el: "#listRendering3",
        data: {
          userObj: {
            name: "Paraskevas",
            surname: "Apostolopoulos",
            address: "111 Main St."
          }
        }
      });
    </pre>
  </code>

      <ul>
        <li v-for="property in userObj">{{property}}</li>
      </ul>

      <p>
        If we would need to access the <code>key</code> of each obj, then we could
        add a second argument for accessing the key, and another one for the indexes.
      </p>
      <code>
        <pre>
      &lt;ul&gt;
        &lt;li v-for="property, key, index in userObj"&gt;{ {index + 1} }. { {key} }: { {property} }&lt;/li&gt;
      &lt;/ul&gt;
        </pre>
      </code>

      <ul>
        <li v-for="property, key, index in userObj">{{index + 1}}. {{key}}: {{property}}</li>
      </ul>
    </div>

    <p>
      Remember: When iterating through an object, the order of the keys in not guaranteed
      to be consistent through different JavaScript engines.
    </p>
  </div>

  <script type="text/javascript">
  var listRendering3 = new Vue ({
    el: "#listRendering3",
    data: {
      userObj: {
        name: "Paraskevas",
        surname: "Apostolopoulos",
        address: "111 Main St."
      }
    }
  });
  </script>




  <h3><code>key</code></h3>
  <p>
    When the elements at <code>v-for</code> get updated, Vue uses a way of patching
    the new elements to the DOM instead of updating the whole DOM's order and the
    appropriate index position.
  </p>
  <p>
    In order for Vue to be able to track each node's identity, we can use the <code>key</code>
    attribute. An ideal value for <code>key</code> can be the the <code>id</code>
    of each element.
  </p>
  <p>
    It is recommended that a <code>key</code> attribute is binded every time a
    <code>v-for</code> directive is being used.
  </p>


  <h2>Array change detection</h2>
  <div id="listRendering4">
    <h3>Mutation methods</h3>
    <p>
      Vue wraps the array mutation methods so that there can be a live update
      when these methods are used. The methods that can be used are:
    </p>
    <code>
      <ul>
        <li>push()</li>
        <li>pop()</li>
        <li>shift()</li>
        <li>unshift()</li>
        <li>unshift()</li>
        <li>splice()</li>
        <li>sort()</li>
        <li>reverse()</li>
      </ul>
    </code>
    <p>
      The advantage of Vue is that when a method is run, the DOM does not update the
      full array. What happens instead is that the elements of the array that are still
      used remain and new elements are added - or patched - instead.
    </p>


    <div class="jumbotron">
      <h4>Example</h4>
      <h5><code>.push()</code></h5>
      <p>
        Enter a new name in the <code>input</code> tag and hit enter. You will see
        that the <code>v-for</code> list gets updated from <code>.push()</code>.
        <code>
          v-on:keydown.enter="$event.target.value === '' ? null : students.push({name: $event.target.value});"
        </code>
      </p>
      <input type="text"
      v-on:keydown.enter="$event.target.value === '' ? null : students.push({name: $event.target.value});"
      v-on:keyup.enter="$event.target.value = ''">
      <ul>
        <li style="list-style: none" v-for="(student, index) in students" :key="index">{{index + 1}}: {{student.name}}</li>
      </ul>
      <h5><code>.reverse(), .sort()</code></h5>
      <p>
        For <code>.reverse()</code>, the code used was:
        <code>v-on:click="students.reverse()"</code>
      </p>
      <button type="button" v-on:click="students.reverse()">Reverse the list</button>
      <p>
        For <code>.sort()</code>, the code used was:
        <code>
          v-on:click="students.sort(function(a,b){return a.name.charCodeAt(0) - b.name.charCodeAt(0);})
        </code>
      </p>
      <button type="button"
      v-on:click="students.sort(function(a,b){return a.name.charCodeAt(0) - b.name.charCodeAt(0);})">
        Sort the list
      </button>
    </div>
    <h3>Non mutating methods / Replacing an array</h3>
    <p>
      The methods <code>.filter() .concat() .slice()</code> are non mutating methods.
      These methods always return a new array instead. When working with non
      mutating methods, we can replace the old array with a new one.
    </p>
    <p>
      For example, regular JavaScript, the <code>.filter()</code> method creates a new Array
      based on which elements pass the condition that is included in the callback
      function. Yet, Vue maintains the existing DOM array elements but it rather
      creates overlapping objects that constitute the new array.
    </p>
    <div class="jumbotron">
      <h4>Example</h4>
      <ul>
        <li v-for="student in students">{{student.name}}</li>
      </ul>
      <input type="text" v-on:keyup.enter="filterIt($event)">
      <p>
        You can filter the list of names by entering some letters in the <code>input</code>
        tag and hitting enter. The <code>filter()</code> method will filter out
        the array that is being iterated in the list above.
      </p>
      <code>
        <pre>
          methods: {
            filterIt: function(event) {
              this.students = this.students.filter(function(el) {
                return el.name.includes(event.target.value);
              });
              event.target.value = "";
            }
          }
        </pre>
      </code>
    </div>
    <h5>Note from me</h5>
    <p>
      Since the methods <code>concat() slice() and filter()</code> are returning
      a new array, there is no way to revert back to the original array.
    </p>



    <h3>Caveats</h3>
    <p>
      Due to limitations in JavaScript, Vue cannot detect certain changes in an
      array. In particular:
    </p>
    <ol>
      <li>When we try to change the value of each element directly: <br>
        <code>
          <pre>
            var vm = new Vue({
              data: {
                items: ['a', 'b', 'c']
              }
            });

            vm.items[1] = 'x';
            <span style="color: gray;">// is NOT reactive. The value in index 1 will not change.</span>
            vm.items.length = 2
            <span style="color: gray;">// is NOT reactive. The length of the array will not change.</span>
          </pre>
        </code>
      </li>
    </ol>

    <p>
      A way to overcome the challenge of changing the values of individual elements
      in the array is by:
    </p>
    <ul>
      <li>
        Using the <code>.splice()</code> method. <br>
        <code>vm.items.splice(indexOfItem, 1, newValue)</code>
      </li>
      <li>
        Using the <code>Vue.set()</code> method in the Vue constructor <br>
        <code>Vue.set(vm.items, indexOfItem, newValue)</code>
      </li>
    </ul>
    <p>
      A way to overcome the challenge of not being able to modify the length of the array,
      we can use <code>splice()</code>. <br>
      <code>vm.items.splice(newLength)</code>
    </p>

    <div class="jumbotron">
      <h4>Example - <code>splice(indexOfItem, 1, newValue)</code> </h4>
      <p>
        Select from the drop down menu which position you would like the new entry
        to be placed at. Then enter a name in the <code>input</code> tag and press
        enter. The <code>.splice()</code> method will update the array.
      </p>

      <ul>
        <li v-for="student in students">{{student.name}}</li>
      </ul>
      <div class="divSpliceArray">
        <h6>Before which position do you want to enter a new name?</h6>
        <select class="" name="">
          <option v-for="student in students" v-bind:value="student.name">Before {{student.name}}</option>
        </select>
        <h6>How many names should be removed?</h6>
        <select class="" name="">
          <option v-for="(student, idx) in students" v-bind:value="idx">{{idx}} names</option>
        </select>
        <h6>What is the new name?</h6>
        <input type="text" name="" value="" v-on:keydown.enter="spliceMe($event)">
      </div>
      <code>
        <pre>
  spliceMe: function(event) {
    if (event.target.value === "") return;

    var dropDownValue = event.path[1].children[1].value;
    var removalOfElements = event.path[1].children[3].value
    var newValue = event.target.value;

    for (var i = 0; i < this.students.length; i++) {
      if (this.students[i].name === dropDownValue){
        this.students.splice(i, removalOfElements, {name: newValue});
        event.target.value = ""
        break;
      }
    }
  }
        </pre>
      </code>
    </div>

    <div class="jumbotron">
      <h4>Example - <code>Vue.set(vm.items, indexOfItem, newValue)</code> </h4>
      <p>
        Same like above, use the drop down menus and the <code>input</code> tag.
      </p>

      <ul>
        <li v-for="student in students">{{student.name}}</li>
      </ul>
      <div class="divVueSetArray">
        <h6>Which name do you want to replace?</h6>
        <select class="" name="">
          <option v-for="(student, idx) in students" :value="student.name">
            {{student.name}}
          </option>
        </select>
        <h6>What is the new name?</h6>
        <input type="text" name="" value="" v-on:keydown.enter="vueSet($event)">
      </div>
      <code>
        <pre>
  vueSet: function(event) {
    if (event.target.value === "") return;
    var dropDownValue = event.path[1].children[1].value;

    for (var i = 0; i < this.students.length; i++) {
      if (this.students[i].name === dropDownValue){
        Vue.set(this.students, i, {name: event.target.value});
        event.target.value = "";
        break;
      }
    }
  }
        </pre>
      </code>

    </div>
  </div>


    <script>
    var listRendering4 = new Vue({
      el: "#listRendering4",
      data: {
        students: [
          {name: "Steve"},
          {name: "Angela"},
          {name: "Simon"},
          {name: "George"},
          {name: "Lisa"}
        ]
      },
      methods: {
        filterIt: function(event) {
          this.students = this.students.filter(function(el) {
            return el.name.includes(event.target.value);
          });
          event.target.value = "";
        },
        spliceMe: function(event) {
          if (event.target.value === "") return;
          //Variables that get the values the user selects in the drop down menus.
          var dropDownValue = event.path[1].children[1].value;
          var removalOfElements = event.path[1].children[3].value
          //Input tag value
          var newValue = event.target.value;
          /*
          make a for loop that iterates through students
          if the element[idx].name === dropDownValue
          Then do the splice
          */

          for (var i = 0; i < this.students.length; i++) {
            if (this.students[i].name === dropDownValue){
              this.students.splice(i, removalOfElements, {name: newValue});
              event.target.value = ""
              break;
            }
          }
        }, //End of spliceMe
        vueSet: function(event) {
          if (event.target.value === "") return;
          var dropDownValue = event.path[1].children[1].value;

          for (var i = 0; i < this.students.length; i++) {
            if (this.students[i].name === dropDownValue){
              Vue.set(this.students, i, {name: event.target.value});
              event.target.value = "";
              break;
            }
          }
        } //end of vueSet
      } //End of methods
    });

    </script>






    <h2>Object change detection caveats</h2>
    <div id="listRendering5">
      <p>
        Due to limitations in JavaScript, Vue cannot add any new REACTIVE
        properties in the <code>data</code> object if they have not been previously declared
        in the Vue constructor.
        Hence: <br>
        <code>
          <pre>
  var vm = new Vue({
    data: {
      a: 1
    }
  })
  <span style="color: gray;">// `vm.a` is now reactive</span>

  vm.b = 2
  <span style="color: gray;">// `vm.b` is NOT reactive</span>
          </pre>
        </code>
      </p>

      <p>
        Vue does not allow the dynamic addition of new properties at the root level
        of a Vue istance. Hence, if we would want to add a new property right
        after the <code>data</code> level, we would not be able to do so.
      </p>
      <p>
        On the other hand, we can add a property inside a nested object with the
        <code>Vue.set()</code> method. This property can be reactive.
      </p>

      <div class="jumbotron">
        <h4>Example</h4>
        <p>
          In the following example, we are adding a new property in the existing
          object that is nested after <code>data</code>.
        </p>
        <ul>
          <li v-for="(user, key) in userProfile">{{key}}: {{user}}</li>
        </ul>
        <div id="addNewProperty">
          Key: <input type="text" name="key" value="" placeholder="Enter key">
          Value: <input type="text" name="value" value="" placeholder="Enter value">
          <button type="button" name="button" v-on:click="addNewProperty($event)">Add new property</button>
        </div>
        <p>
          The code for the above input fields and button is:
        </p>
        <code>
          <pre>
&lt;div id="addNewProperty"&gt;
  Key: &lt;input type="text" name="key" value="" placeholder="Enter key"&gt;
  Value: &lt;input type="text" name="value" value="" placeholder="Enter value"&gt;
  &lt;button type="button" name="button" v-on:click="addNewProperty($event)"&gt;Add new property&lt;/button&gt;
&lt;/div&gt;
          </pre>
        </code>
        <p>The code for the method used is:</p>
        <code>
          <pre>
addNewProperty: function(event) {
  var inputKey = event.path[1].children[0];
  var inputValue = event.path[1].children[1];
  if (inputKey.value.length === 0) return inputKey.placeholder = "KEY NEEDED";
  if (inputValue.value.length === 0) return inputValue.placeholder = "VALUE NEEDED";

  Vue.set(this.userProfile, inputKey.value.toLowerCase(), inputValue.value);
  inputKey.value = "";
  inputValue.value = "";
  inputKey.placeholder = "Enter key";
  inputValue.placeholder = "Enter value";
}
          </pre>
        </code>
      </div>

      <p>
        If we need to assign more than one properties in the object, we can use the
        <code>Object.assign()</code> or <code>_extend()</code> method. In those
        cases, we need to create a fresh object with properties from both objects.
      </p>

      <div class="jumbotron">
        <h4>Example</h4>
        <ul>
          <li v-for="(user, key) in userProfile">{{key}}: {{user}}</li>
        </ul>
        <div class="inputSlot" v-for="(propName, idx) in propNames">
          <label for="" v-if="propName.active">
            {{propName.keyVal.toUpperCase()}}:
            <input type="text"
            :data-index = "idx"
            :data-key-value = "propName.keyVal"
            :placeholder="propName.keyVal"
            @keydown.enter="addSeveralProperties($event)">
          </label>
        </div>


        <p>
          The above list can be modified by entering new information in the input
          field. Contrary to the input fields in the previous example, this
          input field has a <code>v-if</code> that activates the different fields
          one by one. <br>
          There are two objects in the <code>data</code> object. One with preset
          properties whose values are used as the keys. One with no values where all
          the values from the input field will be entered.
        </p>
        <p>
          Before the properties are added in the above object, they first are added
          in a different object that resides in the <code>data</code> property.
          After all the values are added, then the <code>Object.assign</code> method
          is used to add the new properties in the existing object.
        </p>


        <hr>
        <h5>The code for the html is:</h5>
        <code>
          <pre>
&lt;div class="inputSlot" v-for="(propName, idx) in propNames"&gt;
  &lt;label for="" v-if="propName.active"&gt;
    { {propName.keyVal.toUpperCase()} }:
    &lt;input type="text"
    :data-index = "idx"
    :data-key-value = "propName.keyVal"
    :placeholder="propName.keyVal"
    @keydown.enter="addSeveralProperties($event)"&gt;
  &lt;/label&gt;
&lt;/div&gt;
          </pre>
        </code>
        <h5>The code for the method is:</h5>
        <code>
          <pre>
addSeveralProperties: function(event) {
  var inputSlot = event.target;
  var inputSlotValue = event.target.value;
  var inputSlotIndex = event.target.attributes[1].value;
  var inputSlotKey = event.target.attributes[2].value;

  <span style="color: gray;">//If the user did not enter anything in input</span>
  if (inputSlotValue.trim().length === 0){
    inputSlotValue = "";
    return inputSlot.placeholder = "ENTER A VALUE!";
  }


  <span style="color: gray;">//if the idx is smaller than the length of propNames</span>
  if (inputSlotIndex < this.propNames.length) {
    this.profileValues[inputSlot.id] = inputSlotValue; <span style="color: gray;">//Add a value to profile values</span>
    this.propNames[inputSlotIndex].active = false; <span style="color: gray;">//Make propNames value false</span>
    //Make next propNames "active" value true or make the first one true
    !this.propNames[Number(inputSlotIndex) + 1] ?
    this.propNames[0].active = true :
    this.propNames[Number(inputSlotIndex) + 1].active = true;


    <span style="color: gray;">/If the index equals to the amount of elements in the propNames object</span>/
    if (Number(inputSlotIndex) === this.propNames.length - 1) {
      this.userProfile = Object.assign({}, this.userProfile, this.profileValues);
      <span style="color: gray;">//Make the Key value same to the first key value in object. Same for Index.</span>
      inputSlotKey = this.propNames[0].keyVal;
      inputSlotIndex = 0;
    }
  }
}
          </pre>
        </code>
      </div>
    </div>



    <script>
      var listRendering5 = new Vue({
        el: "#listRendering5",
        data: {
          userProfile: {
            name: "Paraskevas"
          },
          propNames: [
            {keyVal: "surname", active: true},
            {keyVal: "streetName", active: false},
            {keyVal: "city", active: false},
            {keyVal: "zip", active: false},
            {keyVal: "state", active: false},
            {keyVal: "telephone", active: false}
          ],
          profileValues: {
            surname: "",
            streetName: "",
            city: "",
            zip: "",
            state: "",
            telephone: ""
          }
        },
        methods: {
          addNewProperty: function(event) {
            var inputKey = event.path[1].children[0];
            var inputValue = event.path[1].children[1];
            if (inputKey.value.length === 0) return inputKey.placeholder = "KEY NEEDED";
            if (inputValue.value.length === 0) return inputValue.placeholder = "VALUE NEEDED";

            Vue.set(this.userProfile, inputKey.value.toLowerCase(), inputValue.value);
            inputKey.value = "";
            inputValue.value = "";
            inputKey.placeholder = "Enter key";
            inputValue.placeholder = "Enter value";
          },
          addSeveralProperties: function(event) {
            var inputSlot = event.target;
            var inputSlotValue = event.target.value;
            var inputSlotIndex = event.target.attributes[1].value;
            var inputSlotKey = event.target.attributes[2].value;
            //If the user did not enter anything in input
            if (inputSlotValue.trim().length === 0){
              inputSlotValue = "";
              return inputSlot.placeholder = "ENTER A VALUE!";
            }


            //if the idx is smaller than the length of propNames
            if (inputSlotIndex < this.propNames.length) {
              this.profileValues[inputSlot.id] = inputSlotValue; //Add a value to profile values
              this.propNames[inputSlotIndex].active = false; //Make propNames value false
              //Make next propNames "active" value true or make the first one true
              !this.propNames[Number(inputSlotIndex) + 1] ?
              this.propNames[0].active = true :
              this.propNames[Number(inputSlotIndex) + 1].active = true;


              //If the index equals to the amount of elements in the propNames object
              if (Number(inputSlotIndex) === this.propNames.length - 1) {
                this.userProfile = Object.assign({}, this.userProfile, this.profileValues);
                //Make the Key value same to the first key value in object. Same for Index.
                inputSlotKey = this.propNames[0].keyVal;
                inputSlotIndex = 0;
              }
            }
          } //End of addSeveralProperties Method
        } //end of methods
      });
    </script>






    <h2>Displaying Filtered / Sorted results</h2>
    <div id="listRendering6">
      <p>
        Sometimes we want to display a filtered or sorted array without mutating
        the data. In this case, we can use a <code>computed</code> property to
        filter through the data.
      </p>

      <div class="jumbotron">
        <h4>Example</h4>
        <p>
          In the following example, there is a <code>v-for</code> loop that displays
          all the users from the users property. There is a <code>v-if</code>
          directive that updates the users that are being displayed based on the
          selection made in the drop down menu. The <code>v-if</code> directive
          is matched with the <code>activeGender</code> property, that gets updated
          from the drop down menu's value.
        </p>
        <p>
          The average age is calculated by a computed property. Based on which
          users are filtered from the <code>users</code> property, the computed property
          calculates the average age.
        </p>
        <ul>
          <li v-for="user in users" v-if="activeGender === user.gender || activeGender === 'Any gender'">{{user.name}}, {{user.age}}</li>
        </ul>
        <p><b>The average age for {{activeGender}} users is {{averageAge}}</b></p>

        <select class="" name="" id="selectSortGender" v-on:change="activeGender = $event.target.value">
          <option value="" disabled selected>Choose from the list</option>
          <option value="Any gender">Any gender</option>
          <option value="male">Males</option>
          <option value="female">Females</option>
        </select>
        <p>
          Use the following drop down menu to filter through the users and also
          get their average age.
        </p>

        <hr>
        <h5>The code for the html is</h5>
        <code>
          <pre>
&lt;ul&gt;
  &lt;li v-for="user in users" v-if="activeGender === user.gender || activeGender === 'Any gender'"&gt;{ {user.name} }, { {user.age} }&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;The average age for { {activeGender} } users is { {averageAge} }&lt;/b&gt;&lt;/p&gt;

&lt;select class="" name="" id="selectSortGender" v-on:change="activeGender = $event.target.value"&gt;
  &lt;option value="" disabled selected&gt;Choose from the list&lt;/option&gt;
  &lt;option value="Any gender"&gt;Any gender&lt;/option&gt;
  &lt;option value="male"&gt;Males&lt;/option&gt;
  &lt;option value="female"&gt;Females&lt;/option&gt;
&lt;/select&gt;
          </pre>
        </code>
        <h5>The code for the Vue instance is</h5>
        <code>
          <pre>
new Vue ({
  el: "#listRendering6",
  data: {
    activeGender: "Any gender",
    users: [
      {name: "Bob", gender: "male", age: 22},
      {name: "Suzan", gender: "female", age: 25},
      {name: "Lisa", gender: "female", age: 33},
      {name: "Tim", gender: "male", age: 38},
      {name: "Luke", gender: "male", age: 23},
      {name: "Nicky", gender: "female", age: 34},
      {name: "Mandy", gender: "female", age: 32},
      {name: "David", gender: "male", age: 20}
    ]
  },
  computed: {
    averageAge: function() {
      var ageTotal = 0;
      if (this.activeGender === "Any gender") {
        this.users.forEach((el, idx, arr) => ageTotal += el.age);
        return ageTotal / this.users.length;
      }

      var filteredGenders = this.users.filter((el) => el.gender === this.activeGender);
      filteredGenders.forEach((el) => ageTotal += el.age);

      return ageTotal / filteredGenders.length;
    }
  }
          </pre>
        </code>
      </div>

      <p>
        In situations where a computed property is not feasible, we can use a method.
        For example, if we are invoking a method that is nested inside the attribute
        text of a <code>v-for</code> loop.
      </p>

      <div class="jumbotron">
        <h4>Example</h4>
        <p>
          In the following example, the drop down menu defines the properties that
          should be filtered in the <code>v-for</code> loop by modifying a data
          property's value ("all numbers", "even", "odd"). This data property is
          then used in the invoked function (that resides inside the v-for loop)
          in order to filter the displayed object.
        </p>
        <span v-for="n in filterNumbers(numbers)">{{n}} </span>
        <select class="" name="" v-on:change="activeNumbers = $event.target.value">
          <option value="all numbers">All numbers</option>
          <option value="odd">Odd numbers</option>
          <option value="even">Even numbers</option>
        </select>

        <hr>
        <h5>The code for the html is</h5>
        <code>
          <pre>
&lt;span v-for="n in filterNumbers(numbers)"&gt;{ {n} } &lt;/span&gt;
&lt;select class="" name="" v-on:change="activeNumbers = $event.target.value"&gt;
  &lt;option value="all numbers"&gt;All numbers&lt;/option&gt;
  &lt;option value="odd"&gt;Odd numbers&lt;/option&gt;
  &lt;option value="even"&gt;Even numbers&lt;/option&gt;
&lt;/select&gt;
          </pre>
        </code>
        <h5>The code for the method is</h5>
        <code>
          <pre>
methods: {
  filterNumbers: function(numbers) {
    if (this.activeNumbers === "odd") return this.numbers.filter((el) => el % 2 !== 0);
    if (this.activeNumbers === "even") return this.numbers.filter((el) => el % 2 === 0);
    return numbers;
  }
          </pre>
        </code>
      </div>
    </div>


    <script type="text/javascript">
      var listRendering6 = new Vue ({
        el: "#listRendering6",
        data: {
          activeGender: "Any gender",
          users: [
            {name: "Bob", gender: "male", age: 22},
            {name: "Suzan", gender: "female", age: 25},
            {name: "Lisa", gender: "female", age: 33},
            {name: "Tim", gender: "male", age: 38},
            {name: "Luke", gender: "male", age: 23},
            {name: "Nicky", gender: "female", age: 34},
            {name: "Mandy", gender: "female", age: 32},
            {name: "David", gender: "male", age: 20}
          ],
          activeNumbers: "all numbers",
          numbers: [1,2,3,4,5,6,7,8,9,10]
        },
        computed: {
          averageAge: function() {
            var ageTotal = 0;
            if (this.activeGender === "Any gender") {
              this.users.forEach((el, idx, arr) => ageTotal += el.age);
              return ageTotal / this.users.length;
            }

            var filteredGenders = this.users.filter((el) => el.gender === this.activeGender);
            filteredGenders.forEach((el) => ageTotal += el.age);

            return ageTotal / filteredGenders.length;
          }
        },
        methods: {
          filterNumbers: function(numbers) {
            if (this.activeNumbers === "odd") return this.numbers.filter((el) => el % 2 !== 0);
            if (this.activeNumbers === "even") return this.numbers.filter((el) => el % 2 === 0);
            return numbers;
          }
        }
      });
    </script>





    <div id="listRendering7">
      <h2><code>v-for</code> with a Range </h2>
      <p>
        <code>v-for</code> can also take an integer. Therefore it will repeat
        that many times.
      </p>
      <div class="jumbotron">
        <h4>Example</h4>
        <p>
          In the following example, we are displaying consecutive <code>span</code>
          tags because we are invoking <code>v-for="n in 5"</code>.
        </p>
        <span style="display: block;" v-for="n in 5">Hello, I am a <code>span</code> and I am displayed at position <b>{{n}}</b></span>
      </div>

      <h2><code>v-for</code> on a template </h2>
      <p>
        Similar to <code>v-if</code>, we can use the <code>v-for</code> in a
        <code>template</code> tag in order to display a group of tags together.
        Alternatively, we could also use other tags that would contribute to the
        grouping process (ex: <code>div</code>).
      </p>

      <div class="jumbotron">
        <h4>Example</h4>
        <template id="" v-for="person in people">
          <h6>{{person.name}} {{person.surname}}</h6>
          <p>{{person.name}}'s favorite color is {{person.color}}.</p>
        </template>

        <hr>
        <h5>The html code used is</h5>
        <code>
          <pre>
&lt;template id="" v-for="person in people"&gt;
  &lt;h6&gt;{ {person.name} } { {person.surname} }&lt;/h6&gt;
  &lt;p&gt;{ {person.name} }'s favorite color is { {person.color} }.&lt;/p&gt;
&lt;/template&gt;
          </pre>
        </code>
      </div>

      <h2><code>v-for</code> with <code>v-if</code> </h2>
      <p>
        If they exist in the same node, <code>v-for</code> has a priority over
        <code>v-if</code>. That means that <code>v-if</code> will be run at every
        iteration separately. This can be used when we want to render nodes of
        only <i>some</i> of the items. See the example right after the heading:
        <b>"Displaying Filtered / Sorted results"</b>.
      </p>
      <p>
        Alternatively, <code>v-for</code> can be inside a node that is the child of
        another node whithin which a <code>v-if</code> is implemented. In that case,
        the <code>v-if</code> condition defines if the <code>v-for</code> loop will
        be implemented, since the node that hosts the loop will either render or not.
      </p>

      <div class="jumbotron">
        <h4>Example</h4>
        <p>
          In the following example, you will see how clicking on the checkboxes
          removes elements from the list. You will see that as soon as the list
          reaches the length of three entries, it will dissapear because the
          <code>v-if</code> conditional kicks in.
        </p>
        <p>
          What is happening in the method used is that the value of the <code>input</code>
          is matched with the related index position in the array used in the <code>v-for</code>
          loop. Then this index number is used to <code>.splice()</code> inside
          the array. Also the checkbox is deselected. The last two actions are happening
          within a <code>setTimeout</code> method in order to make the experience
          better for the user.
        </p>
        <h6>The length of the list is {{people.length}}</h6>
        <div class="conditionalDisplay" v-if="people.length > 3">
          <ul>
            <li v-for="person in people">
              <input type="checkbox"
              :value="person.surname"
              @click="clickLeave($event)">
              {{person.name}} {{person.surname}} likes {{person.color}}
            </li>
          </ul>
        </div>
        <hr>
        <h5>The code in the html is</h5>
        <code>
          <pre>
&lt;div class="conditionalDisplay" v-if="people.length > 3">
  &lt;ul&gt;
    &lt;li v-for="person in people"&gt;
      &lt;input type="checkbox" :value="person.surname"@click="clickLeave($event)"&gt;
      { {person.name} } { {person.surname} } likes { {person.color} }
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
          </pre>
        </code>
        <h5>The code in the Vue component is:</h5>
        <code>
          <pre>
clickLeave: function(event) {
  var checkValue = event.target.value;
  var idxPosition = this.people.findIndex((el) => el.surname === checkValue);
  var people = this.people;
  setTimeout(() => {
    people.splice(idxPosition, 1);
    event.target.checked = false;
  }, 500);
}
          </pre>
        </code>
      </div>

    </div> <!--End of listRendering7 -->


    <script>
      var listRendering7 = new Vue({
        el: "#listRendering7",
        data: {
          people: [
            {name: "John", surname:"Smith", color:"green"},
            {name: "Jessica", surname:"Rabbit", color:"orange"},
            {name: "Lucifer", surname:"Devil", color:"red"},
            {name: "Angel", surname:"Sweet", color:"white"},
            {name: "Winnie", surname:"Pooh", color:"brown"},
            {name: "God", surname:"Mighty", color:"black"},
            {name: "Zeus", surname:"Olympian", color:"electric"}
          ],
          clickLeave: function(event) {
            var checkValue = event.target.value;
            var idxPosition = this.people.findIndex((el) => el.surname === checkValue);
            var people = this.people;
            setTimeout(() => {
              people.splice(idxPosition, 1);
              event.target.checked = false;
            }, 500);
          }
        }
      });
    </script>





    <h2><code>v-for</code> with a component </h2>
    <div id="listRendering8">
      <p>
        A <code>v-for</code> can be used directly on a component. When a <code>v-for</code>
        is used on a component, a <code>key</code> needs to be binded as well.
      </p>
      <p>
        In addition, <code>props</code> need to be used in the component in order
        to pass the iterated data. Data cannot be passed automatically because
        components have isolated scopes.
      </p>
      <p>
        <b>I DO NOT UNDERSTAND THIS:</b> <br>
        The reason why we are not automatidally injecting the <code>item</code>
        into the component is because that makes the component tightly coupled to
        how <code>v-for</code> works. Being explicit about where the data comes from
        makes the component reusable in other situations.
      </p>

      <div class="jumbotron">
        <h4>Example</h4>
        <p>
          The following example is from the online tutorial. I would need to make
          my own some time.
        </p>
        <div id="todo-list">
          <form v-on:submit.prevent="addNewToDo">
            <label for="new-todo"></label>
            <input id="new-todo"
            type="text"
            placeholder="eg: Get a haircut"
            v-model="newToDoText">
            <button>Submit</button>
          </form>

          <ul>
            <li
            is="todo-item"
            v-for="(item, index) in todos"
            :key="item.id"
            :title="item.title"
            v-on:remove="todos.splice(index, 1)"
            ></li>
          </ul>
        </div>
      </div>
    </div>


    <script>
    Vue.component("todo-item", {
      props: ["title"],
      template: `
      <li>
        {{title}}
      </li>
      `
    });

      var listRendering8 = new Vue({
        el: "#listRendering8",
        data: {
          todos: [
            {id: 1, title: "Do the dishes."},
            {id: 2, title: "Walk the dog."},
            {id: 3, title: "Buy groceries."},
            {id: 4, title: "Fold the laundry."}
          ],
          newToDoText: "",
          nextToDoId: 5
        },
        methods: {
          addNewToDo: function() {
            this.todos.push({
              id: this.nextToDoId,
              title: this.newToDoText
            });
            this.nextToDoId += 1;
            this.newToDoText = "";
          }
        }
      });
    </script>














<a href="./005.html">Previous - Conditional Rendering</a> <a href="./007.html">Next - Event handling</a>

</body>
</html>
