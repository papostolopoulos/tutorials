<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <!-- <script type="text/javascript" src="https://unpkg.com/vue@2.2.6"></script> -->
  <script type="text/javascript" src="./vue.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  <link rel="stylesheet" href="./styles.css">  <style media="screen">
  body {
    padding: 15px;
  }
  </style>

  <title>003 - Computed properties and watchers - Vue website tutorial</title>
</head>
<body>

  <h3><a href="https://vuejs.org/v2/guide/computed.html">Source</a></h3>

  <h1>004 - Computed Properties and Watchers</h1>

  <div id="computedProperties1">
    <h2>Computed properties</h2>
    <p>The expressions that are inside the template are useful for relatively simple operations but
    can be bloated in size if the application we are building tends to be more complex.</p>
    <div class="jumbotron">
      <h4>Example</h4>
      <code>
        &lt;div id="example"&gt; <br>
        { { message.split('').reverse().join('') } } <br>
        &lt;/div&gt;
      </code>
    </div>

    <p>At the above example, the template loses its simplicity since it becomes long.
    Therefore it is no longer declarative. Also if the same methods have to be incorporated
    in more than one locations in the html text, the code tends to be repetitive in
    an unecessary way.</p>
    <p>The computed properties are serving the purpose of simplyfying a complex logic
    like the above.</p>



    <h3>NOTE (as I understand it from
      <a href="https://stackoverflow.com/questions/44350862/method-vs-computed-in-vue">Github</a>)
    </h3>
    <p>A computed property is a <b>property</b> of the Vue instance that is <b>"COMPUTED"</b>
    - meaning that it is created from the existing properties in <code>data</code>.</p>
    <p>The computed property is NOT a method, because it does not have to be called but
    it is automatically computed every time the <code>data</code> is updated.</p>

    <div class="jumbotron">
      <h4>Example</h4>
      <p>The code here:</p>
      <pre>
        &lt;div id="example"&gt;
          &lt;p&gt;Original message: "{{ message }}"&lt;/p&gt;
          &lt;p&gt;Computed reversed message: "{{ reversedMessage }}"&lt;/p&gt;
        &lt;/div&gt;
      </pre>
      <p>with the vue here:</p>
      <pre>
          var computedProperties1 = new Vue ({
            el: "#computedProperties1",
            data: {
              message: "Hello"
            },
            computed: {
              reversedMessage() {
                return this.message.split("").reverse().join("");
              }
            }
          });
      </pre>
      <p>can display the following:</p>
      <p>Original message: "{{ message }}" - <code>{ { message } }</code></p>
      <p>Computed reversed message: "{{ reversedMessage }}" - <code>{ { reversedMessage } }</code> </p>
    </div>



    <h3>Computed properties vs Methods</h3>
    <p>Instead of a computed property, we can define the same function as a method.
      For the end result, the two approaches are indeed exactly the same. <br>
      However, the difference is that computed properties are cached based on their
      dependencies. (meaning the data they are binded on)<br>
      A computed property will only re-evaluate when some of its dependencies have changed. <br>
      This means as long as <code>message</code> has not changed, multiple access
      to the <code>reverseMessage</code> computed property will immediately return the
      previously computed result without having to run the function again.<br>
      In comparison, a method invocation will <b>always</b> run the function
      whenever a re-render happens.<br>
    </p>


  <h4>Why do we need caching?</h4>
  <p> Imagine we have an expensive computed property A, which requires looping
    through a huge Array and doing a lot of computations.<br>
    Then we may have other computed properties that in turn depend on A.
    Without caching, we would be executing A’s getter many more times than necessary! <br>
    In cases where you do not want caching, use a method instead.</p>


  <h4>Computed Setter</h4>
  <p>Even though computed properties are getters only, they can also provide a setter.</p>
  <div class="jumbotron">
    <h4>Example</h4>
    <p>The following displays a computed property that is binded on properties
      from <code>data</code>. The computed property is </p>
      <h5>{{fullName}}</h5>
      <p>It can change from the value of the input box. Need to fix that. How
      can I be able to use the setter? It currently works with a method and not
      with the setter in the computed property.</p>
      <input type="text" id="someInput" name="" v-on:keyup.enter="nameMe($event)" value="">


  </div>




  </div>












  <div id="watch-example">
    <h3>Watchers</h3>
    <p>While computed properties are more appropriate in most cases, there are
      times when a custom watcher is necessary.<br>
      That’s why Vue provides a more generic way to react to data changes
      through the watch option. <br>
      This is most useful when you want to perform asynchronous or expensive
      operations in response to changing data.</p>

      <p>Ask a yes or no question
      <input v-model="question">
      </p>

      <p>In this case, using the watch option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, <br>
        and set intermediary states until we get a final answer. None of that would be possible with a computed property.</p>
      <p>{{answer}}</p>
  </div>

  <!-- Since there is already a rich ecosystem of ajax libraries    -->
  <!-- and collections of general-purpose utility methods, Vue core -->
  <!-- is able to remain small by not reinventing them. This also   -->
  <!-- gives you the freedom to just use what you're familiar with. -->
  <script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
  <script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>





  <script type="text/javascript">
    var computedProperties1 = new Vue ({
      el: "#computedProperties1",
      data: {
        message: "Hello",
        firstName: "John",
        lastName: "Doe"
      },
      computed: {
        reversedMessage() {
          return this.message.split("").reverse().join("");
        },
        fullName: {
          get: function() {
            return this.firstName + " " + this.lastName;
          },
          set: function(nameValue) {
            var names = nameValue.split(' ');
            this.firstName = names[0];
            this.lastName = names[names.length - 1];
          }
        }
      },
      methods: {
        nameMe: function(event) {
          var names = event.target.value.split(' ');
          this.firstName = names[0];
          this.lastName = names[names.length - 1];
        }
      }
    });

    var watchExampleVM = new Vue({
      el: "#watch-example",
      data: {
        question: '',
        answer: 'I cannot give you an answer until you ask a question'
      },
      watch: {
        question: function (newQuestion) {
          this.answer = 'Waiting for you to stop typing';
          this.getAnswer();
        }
      },
      methods: {
        // _.debounce is a function provided by lodash to limit how
        // often a particularly expensive operation can be run.
        // In this case, we want to limit how often we access
        // yesno.wtf/api, waiting until the user has completely
        // finished typing before making the ajax request. To learn
        // more about the _.debounce function (and its cousin
        // _.throttle), visit: https://lodash.com/docs#debounce
        getAnswer: _.debounce(
          function () {
            if (this.question.indexOf('?') === -1) {
              this.answer = 'Questions usually contain a question mark ;-)';
              return
            }
            this.answer = "Thinking...";
            var vm = this;
            axios.get('https://yesno.wtf/api')
            .then(function (response) {
              vm.answer = _.capitalize(response.data.answer);
            })
            .catch(function (error) {
              vm.answer = 'Error! Could not reach the API' + error;
            })
          },
          //This is the number of miliseconds we wait for the user to stop typing
          500
        )
      }
    });


  </script>


  <a href="./002.html">Previous - Template Syntax</a> <a href="./004.html">Next - Class and Style bindings</a>

</body>
</html>
