<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <script type="text/javascript" src="./vue.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  <link rel="stylesheet" href="styles.css">

  <title>007 - Event Handling - Vue website tutorial</title>
</head>
<body>

  <a href="https://vuejs.org/v2/guide/events.html"><h3>Source</h3></a>

  <h1>7 - Event Handling</h1>


  <div id="eventHandling1">
    <h2>Listening to events</h2>
    <p>
      The <code>v-on</code> directive can be used to listen to DOM events. JavaScript
      can be implemented with these events.
    </p>

    <div class="jumbotron">
      <h4>Example</h4>
      <p>
        In the following example, we can do basic arithmetic calculations based
        on the entry in the <code>input</code> tag and the button we click on.
      </p>
      <input type="text" name="" value="" v-model="counter">
      <button type="button" name="button" @click="result += Number(counter)">Add</button>
      <button type="button" name="button" @click="result -= Number(counter)">Subtract</button>
      <button type="button" name="button" @click="result *= Number(counter)">Multiply</button>
      <button type="button" name="button" @click="result /= Number(counter)">Divide</button>
      <button type="button" name="button" @click="result = 0">Make zero</button>
      <p>The result is: {{result}}</p>
      <hr>
      <h6>The code for the html is:</h6>
      <code>
        <pre>
          &lt;input type="text" name="" value="" v-model="counter"&gt;
          &lt;button type="button" name="button" @click="result += Number(counter)"&gt;Add&lt;/button&gt;
          &lt;button type="button" name="button" @click="result -= Number(counter)"&gt;Subtract&lt;/button&gt;
          &lt;button type="button" name="button" @click="result *= Number(counter)"&gt;Multiply&lt;/button&gt;
          &lt;button type="button" name="button" @click="result /= Number(counter)"&gt;Divide&lt;/button&gt;
          &lt;button type="button" name="button" @click="result = 0"&gt;Make zero&lt;/button&gt;
        </pre>
      </code>
      <h6>The code for the script is</h6>
      <code>
        <pre>
          el: "#eventHandling1",
          data: {
            result: 0,
            counter: 0
          }
        </pre>
      </code>
    </div>
  </div>

  <script>
    var eventHandling1 = new Vue({
      el: "#eventHandling1",
      data: {
        result: 0,
        counter: 0
      }
    });
  </script>







  <div id="eventHandling2">
    <h2>Methods in Event Handlers</h2>
      <p>
        Even though the event handlers are effective in managing small snippets
        of code and return some results on the page, they might not be so effective
        in managing the code within the html tag since the code might be too long
        in size. Event handlers can easily get methods attached to them and invoke
        results that are based on lengthier sizes of code.
      </p>
      <div class="jumbotron">
        <h4>Example</h4>
        <p>
          In the following example, the <code>greet</code> method is attached on
          the event handler. As you can see below, the code written for this
          page behavior was big so it was better that it was added inside a method.
        </p>
        <button type="button" name="button" @click="greet($event)">When was I last clicked?</button>
        <hr>
        <h6>html code</h6>
        <code>
          &lt;button type="button" name="button" @click="greet($event)"&gt;When was I last clicked?&lt;/button&gt;
        </code>
        <h6>Vue code</h6>
        <code><pre>
  var eventHandling2 = new Vue({
    el: "#eventHandling2",
    data: {
      timeStamp: 0
    },
    methods: {
      greet(event){
        var timeStamp = 0;
        alert(`${messages(this)}
          Just now it was clicked at ${Math.round(event.timeStamp / 1000)} seconds.`);
          this.timeStamp = Math.round(event.timeStamp / 1000);

          function messages(self) {
            return self.timeStamp === 0?
            `This button was not clicked before.`:
            `This button was clicked before at ${self.timeStamp} seconds.`
          }
      }
    }
  });
          </pre></code>
      </div>
  </div>

  <script>
    var eventHandling2 = new Vue({
      el: "#eventHandling2",
      data: {
        timeStamp: 0
      },
      methods: {
        greet(event){
          var timeStamp = 0;
          alert(`${messages(this)}
            Just now it was clicked at ${Math.round(event.timeStamp / 1000)} seconds.`);
            this.timeStamp = Math.round(event.timeStamp / 1000);

            function messages(self) {
              return self.timeStamp === 0?
              `This button was not clicked before.`:
              `This button was clicked before at ${self.timeStamp} seconds.`
            }
        }
      }
    });
  </script>










  <div id="eventHandling3">
    <h2>Methods in Inline handlers</h2>
    <p>
      The methods that are binded in the event handlers can also have parameters
      passed to them as inline arguments. The arguments can either be built in
      variables (ex: <code>$event</code>) or arguments that are connected to the
      user's interaction to the page.
    </p>
    <div class="jumbotron">
      <h4>Example</h4>
      <p>
        Write something, anything and I will alert it for you.
      </p>
      <input type="text" name="" value="">
      <button type="button" name="button" @click="alertMe($event)">Do it!</button>

      <hr>
      <h6>html code</h6>
      <code><pre>
        &lt;button type="button" name="button" @click="alertMe($event)"&gt;Do it!&lt;/button&gt;
      </pre></code>
      <h6>Vue code</h6>
      <code><pre>
        var eventHandling3 = new Vue({
          el: "#eventHandling3",
          data: {
            message: ""
          },
          methods: {
            alertMe(event){
              alert(event.target.previousElementSibling.value === "" ?
                "Enter some text will you?" :
                event.target.previousElementSibling.value);
            }
          }
        });
      </pre></code>
    </div>

  </div>

  <script>
    var eventHandling3 = new Vue({
      el: "#eventHandling3",
      data: {
        message: ""
      },
      methods: {
        alertMe(event){
          alert(event.target.previousElementSibling.value === "" ?
            "Enter some text will you?" :
            event.target.previousElementSibling.value);
        }
      }
    });
  </script>











  <style media="screen">
    .outer {
      border: 2px solid black;
      padding: 20px;
      background-color: white;
      width: 200px;
      height: 200px;
      margin-bottom: 10px;
    }

    .outer-clicked{
      background-color: gray;
    }

    .middle {
      padding: 20px;
      background-color: red;
      width: auto;
      height: 100%;
    }

    .middle-clicked{
      background-color: pink;
    }

    .inner{
      padding: 20px;
      background-color: green;
      width: auto;
      height: 100%;
    }

    .inner-clicked{
      background-color: lime;
    }

    .code, .square{
      display: inline-block;
    }

  </style>

  <div id="eventHandling4">
    <h2>Event modifiers</h2>
    <p>
      Vue has modifiers that replicate JavaScript's built in modifiers and can be
      attached on the event modifier, instead of running the JavaScript Modifiers
      inside the run function. For example, instead of invoking
      <code>event.preventDefault()</code>, we can use
      <code>v-on:click.<b>prevent</b></code>.
    </p>
    <p>
      All the modifiers are postfixes denoted by a dot.
      <ul>
        <li>
          <code><b>.stop</b></code> - Similar to: <code>Event.stopPropagation()</code> <br>
          No propagation of the current event allowed in the capturing or bubbling phases
        </li>
        <li>
          <code><b>.prevent</b></code>  - Similar to: <code>Event.preventDefault()</code> <br>
          Prevents the default action should not be handled as it would normaly
          be. For example, a form will not refresh a page on submit or a checkbox
          will not be selected.
        </li>
        <li>
          <code>.capture</code> - Similar to:
          <code>target.(add or remove)EventListener(type, listener, {capture: true});</code> <br>
          Bubbling phase disabled. Only capture phase enabled.
        </li>
        <li>
          <code>.self</code> - Similar to: <br>
          Triggers handle if the <code>event.target</code> is the element itself.
          So if I click on a different handle, the event will not propagate at the
          specific element (but it will bubble up to other elements that have event
          listeners).
        </li>
        <li>
          <code>.once</code> - Similar to:
          <code>target.(add or remove)EventListener(type, listener, {once: true});</code> <br>
          Triggers the event only once and then it is done. After the first trigger,
          the event listener will not do anything else. Alternatively one could use
          the <code>removeEventListener</code> but that results into having to remember
          the name of the element in order to call the method.
        </li>
        <li>
          <code>.passive</code> - Similar to:
          <code>target.(add or remove)EventListener(type, listener, {passive: true});</code> <br>
          Does not allow <code>preventDefault</code> to kick in when expensive
          JavaScript is running, resulting into the prevention of expected Browser
          behavior (ex: scrolling would be prevented if the page does not fully load)
        </li>
      </ul>
      Since the order of executing the modifiers is happening in the way they are
      written, the order matters. For example, <code>v-on:click.prevent.self</code>
      will prevent the default action and <code>.self</code> will never execute.
      On the other hand, <code>v-on:click.self.prevent</code> will allow <code>self</code>
      to execute first and then <code>prevent</code> will execute.
    </p>

    <div class="jumbotron">
      <h4>Example</h4>
      <h5>Classic bubble</h5>
      <p>
        The following set of squares imitates the behavior of all the events
        bubbling out. This is set with a timeout so that it can present how the
        bubbling behavior would execute, but in a slower motion.
      </p>
      <div class="square">
        <div class="outer" id="outerBubble" @click="bubble($event)">
          <div class="middle" id="middleBubble" @click="bubble($event)">
            <div class="inner" id="innerBubble" @click="bubble($event)">
            </div>
          </div>
        </div>

        <div class="code">

        </div>


        <h5>Capture</h5>
        <p>
          The following set of squares imitates the behavior of all the events
          happening with <code>capture : true</code>. This is set with a timeout
          so that it can present how the behavior would execute,
          but in a slower motion.
        </p>
        <div class="square">
          <div ref="outer" class="outer" id="outerBubbleCapture" @click.capture="capture($event)">
            <div ref="middle" class="middle" id="middleBubbleCapture" @click.capture="capture($event)">
              <div ref="inner" class="inner" id="innerBubbleCapture" @click.capture="capture($event)">
              </div>
            </div>
          </div>
        </div>

          <div class="code">
            <h6>
              html code
              (capture not working because the <code>setTimeout</code> manages the
              capture phase)
            </h6>
            <code> <pre>

            </pre> </code>
            <h6>Vue code</h6>
            <code> <pre>

            </pre> </code>
          </div>



      </div>

      <div class="code">
        <h6>
          html code
          (capture not working because the <code>setTimeout</code> manages the
          capture phase)
        </h6>
        <code> <pre>

        </pre> </code>
        <h6>Vue code</h6>
        <code> <pre>

        </pre> </code>
      </div>
    </div>
  </div>

  <script>
  var eventHandling4 = new Vue({
    el: "#eventHandling4",
    data: {

    }, //End of data
    methods: {
      bubble(event){
        for (let i = 1; i < 4; i++) {
          setTimeout(function() {
            if (!event.path[i-1].className.includes("-clicked")) {
              event.path[i-1].className += " " + event.path[i-1].className +"-clicked";
              console.log(event.path[i-1]);
              console.log(i-1);
            }
          }, i*1000);
        }
      },
      capture(event){
        let two = 0, one = 0, zero = 0;
        for (let i = 2; i >= 0; i--) {
          two === 0 ? two = i : one === 0 ? one = i + 1 : zero = i + 2;
          setTimeout(function() {
            console.log(i);
            if (!event.path[i].className.includes("-clicked")) {
              console.log("In if");
              event.path[i].className += " " + event.path[i].className +"-clicked";
            }
            console.log("after the if", event.path[i]);
            console.log(i);
          }, (two + one + zero)*500);

        }
      }
    } //End of methods
  });

  </script>


  <a href="./006-list_rendering.html">Previous - List Rendering</a> <a href="./008-form_input_bindings.html">Next - Form Input Bindings</a>

</body>
</html>
