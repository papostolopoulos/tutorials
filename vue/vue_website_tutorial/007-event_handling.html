<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <script type="text/javascript" src="./vue.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  <link rel="stylesheet" href="styles.css">

  <title>007 - Event Handling - Vue website tutorial</title>
</head>
<body>

  <a href="https://vuejs.org/v2/guide/events.html"><h3>Source</h3></a>

  <h1>7 - Event Handling</h1>


  <div id="eventHandling1">
    <h2>Listening to events</h2>
    <p>
      The <code>v-on</code> directive can be used to listen to DOM events. JavaScript
      can be implemented with these events.
    </p>

    <div class="jumbotron">
      <h4>Example</h4>
      <p>
        In the following example, we can do basic arithmetic calculations based
        on the entry in the <code>input</code> tag and the button we click on.
      </p>
      <input type="text" name="" value="" v-model="counter">
      <button type="button" name="button" @click="result += Number(counter)">Add</button>
      <button type="button" name="button" @click="result -= Number(counter)">Subtract</button>
      <button type="button" name="button" @click="result *= Number(counter)">Multiply</button>
      <button type="button" name="button" @click="result /= Number(counter)">Divide</button>
      <button type="button" name="button" @click="result = 0">Make zero</button>
      <p>The result is: {{result}}</p>
      <hr>
      <h6>The code for the html is:</h6>
      <code>
        <pre>
          &lt;input type="text" name="" value="" v-model="counter"&gt;
          &lt;button type="button" name="button" @click="result += Number(counter)"&gt;Add&lt;/button&gt;
          &lt;button type="button" name="button" @click="result -= Number(counter)"&gt;Subtract&lt;/button&gt;
          &lt;button type="button" name="button" @click="result *= Number(counter)"&gt;Multiply&lt;/button&gt;
          &lt;button type="button" name="button" @click="result /= Number(counter)"&gt;Divide&lt;/button&gt;
          &lt;button type="button" name="button" @click="result = 0"&gt;Make zero&lt;/button&gt;
        </pre>
      </code>
      <h6>The code for the script is</h6>
      <code>
        <pre>
          el: "#eventHandling1",
          data: {
            result: 0,
            counter: 0
          }
        </pre>
      </code>
    </div>
  </div>

  <script>
    var eventHandling1 = new Vue({
      el: "#eventHandling1",
      data: {
        result: 0,
        counter: 0
      }
    });
  </script>







  <div id="eventHandling2">
    <h2>Methods in Event Handlers</h2>
      <p>
        Even though the event handlers are effective in managing small snippets
        of code and return some results on the page, they might not be so effective
        in managing the code within the html tag since the code might be too long
        in size. Event handlers can easily get methods attached to them and invoke
        results that are based on lengthier sizes of code.
      </p>
      <div class="jumbotron">
        <h4>Example</h4>
        <p>
          In the following example, the <code>greet</code> method is attached on
          the event handler. As you can see below, the code written for this
          page behavior was big so it was better that it was added inside a method.
        </p>
        <button type="button" name="button" @click="greet($event)">When was I last clicked?</button>
        <hr>
        <h6>html code</h6>
        <code>
          &lt;button type="button" name="button" @click="greet($event)"&gt;When was I last clicked?&lt;/button&gt;
        </code>
        <h6>Vue code</h6>
        <code><pre>
  var eventHandling2 = new Vue({
    el: "#eventHandling2",
    data: {
      timeStamp: 0
    },
    methods: {
      greet(event){
        var timeStamp = 0;
        alert(`${messages(this)}
          Just now it was clicked at ${Math.round(event.timeStamp / 1000)} seconds.`);
          this.timeStamp = Math.round(event.timeStamp / 1000);

          function messages(self) {
            return self.timeStamp === 0?
            `This button was not clicked before.`:
            `This button was clicked before at ${self.timeStamp} seconds.`
          }
      }
    }
  });
          </pre></code>
      </div>
  </div>

  <script>
    var eventHandling2 = new Vue({
      el: "#eventHandling2",
      data: {
        timeStamp: 0
      },
      methods: {
        greet(event){
          var timeStamp = 0;
          alert(`${messages(this)}
            Just now it was clicked at ${Math.round(event.timeStamp / 1000)} seconds.`);
            this.timeStamp = Math.round(event.timeStamp / 1000);

            function messages(self) {
              return self.timeStamp === 0?
              `This button was not clicked before.`:
              `This button was clicked before at ${self.timeStamp} seconds.`
            }
        }
      }
    });
  </script>










  <div id="eventHandling3">
    <h2>Methods in Inline handlers</h2>
    <p>
      The methods that are binded in the event handlers can also have parameters
      passed to them as inline arguments. The arguments can either be built in
      variables (ex: <code>$event</code>) or arguments that are connected to the
      user's interaction to the page.
    </p>
    <div class="jumbotron">
      <h4>Example</h4>
      <p>
        Write something, anything and I will alert it for you.
      </p>
      <input type="text" name="" value="">
      <button type="button" name="button" @click="alertMe($event)">Do it!</button>

      <hr>
      <h6>html code</h6>
      <code><pre>
        &lt;button type="button" name="button" @click="alertMe($event)"&gt;Do it!&lt;/button&gt;
      </pre></code>
      <h6>Vue code</h6>
      <code><pre>
        var eventHandling3 = new Vue({
          el: "#eventHandling3",
          data: {
            message: ""
          },
          methods: {
            alertMe(event){
              alert(event.target.previousElementSibling.value === "" ?
                "Enter some text will you?" :
                event.target.previousElementSibling.value);
            }
          }
        });
      </pre></code>
    </div>

  </div>

  <script>
    var eventHandling3 = new Vue({
      el: "#eventHandling3",
      data: {
        message: ""
      },
      methods: {
        alertMe(event){
          alert(event.target.previousElementSibling.value === "" ?
            "Enter some text will you?" :
            event.target.previousElementSibling.value);
        }
      }
    });
  </script>











  <style media="screen">
    .outer {
      border: 2px solid black;
      padding: 20px;
      background-color: white;
      width: 200px;
      height: 200px;
      margin-bottom: 10px;
    }

    .outer-clicked{
      background-color: gray;
    }

    .middle {
      padding: 20px;
      background-color: red;
      width: auto;
      height: 100%;
    }

    .middle-clicked{
      background-color: pink;
    }

    .inner{
      padding: 20px;
      background-color: green;
      width: auto;
      height: 100%;
    }

    .inner-clicked{
      background-color: lime;
    }

    .code, .square{
      display: inline-block;
      padding: 0 10px;
    }


  </style>

  <div id="eventHandling4">
    <h2>Event modifiers</h2>
    <p>
      Vue has modifiers that replicate JavaScript's built in modifiers and can be
      attached on the event modifier, instead of running the JavaScript Modifiers
      inside the run function. For example, instead of invoking
      <code>event.preventDefault()</code>, we can use
      <code>v-on:click.<b>prevent</b></code>.
    </p>
    <p>
      All the modifiers are postfixes denoted by a dot.
      <ul>
        <li>
          <code><b>.stop</b></code> - Similar to: <code>Event.stopPropagation()</code> <br>
          No propagation of the current event allowed in the capturing or bubbling phases
        </li>
        <li>
          <code><b>.prevent</b></code>  - Similar to: <code>Event.preventDefault()</code> <br>
          Prevents the default action should not be handled as it would normaly
          be. For example, a form will not refresh a page on submit or a checkbox
          will not be selected.
        </li>
        <li>
          <code><b>.capture</b> </code> - Similar to:
          <code>target.(add or remove)EventListener(type, listener, {capture: true});</code> <br>
          Bubbling phase disabled. Only capture phase enabled.
        </li>
        <li>
          <code><b>.self</b></code> - Similar to: <br>
          Triggers handle if the <code>event.target</code> is the element itself.
          So if I click on a different handle, the event will not propagate at the
          specific element (but it will bubble up to other elements that have event
          listeners).
        </li>
        <li>
          <code> <b>.once</b> </code> - Similar to:
          <code>target.(add or remove)EventListener(type, listener, {once: true});</code> <br>
          Triggers the event only once and then it is done. After the first trigger,
          the event listener will not do anything else. Alternatively one could use
          the <code>removeEventListener</code> but that results into having to remember
          the name of the element in order to call the method.
        </li>
        <li>
          <code><b>.passive</b> </code> - Similar to:
          <code>target.(add or remove)EventListener(type, listener, {passive: true});</code> <br>
          Does not allow <code>preventDefault</code> to kick in when expensive
          JavaScript is running, resulting into the prevention of expected Browser
          behavior (ex: scrolling would be prevented if the page does not fully load)
        </li>
      </ul>
      Since the order of executing the modifiers is happening in the way they are
      written, the order matters. For example, <code>v-on:click.prevent.self</code>
      will prevent the default action and <code>.self</code> will never execute.
      On the other hand, <code>v-on:click.self.prevent</code> will allow <code>self</code>
      to execute first and then <code>prevent</code> will execute.
    </p>

    <div class="jumbotron">
      <h4>Example</h4>
      <h5>Classic bubble</h5>
      <p>
        The following set of squares imitates the behavior of all the events
        bubbling out. This is set with a timeout so that it can present how the
        bubbling behavior would execute, but in a slower motion.
      </p>
      <div class="square">
        <div class="outer" id="outerBubble" @click="bubble($event)">
          <div class="middle" id="middleBubble" @click="bubble($event)">
            <div class="inner" id="innerBubble" @click="bubble($event)">
            </div>
          </div>
        </div>
      </div>

        <div class="code">
          <hr>
          <h6>html code</h6>
          <code> <pre>
&lt;div class="outer" id="outerBubble" @click="bubble($event)"&gt;
  &lt;div class="middle" id="middleBubble" @click="bubble($event)"&gt;
    &lt;div class="inner" id="innerBubble" @click="bubble($event)"&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
          </pre> </code>
          <h6>Vue code</h6>
          <code> <pre>
bubble(event){
  for (let i = 1; i &lt; 4; i++) {
    setTimeout(function() {
      if (!event.path[i-1].className.includes("-clicked")) {
        event.path[i-1].className += " " + event.path[i-1].className +"-clicked";
      }
    }, i*1000);
  }
} </pre> </code>
        </div>


        <h5>Capture</h5>
        <p>
          The following set of squares imitates the behavior of all the events
          happening with <code>capture: true</code>. This is set with a timeout
          so that it can present how the behavior would execute,
          but in a slower motion.
        </p>
        <p>
          For this code, even though entered, the <code>.capture</code> is
          not working because the <code>setTimeout</code> manages the capture phase
          instead. The <code>setTimeout</code> was entered to better display
          what the <code>.capture</code> modifier does.
        </p>
        <div class="square">
          <div ref="outer" class="outer" id="outerBubbleCapture" @click.capture="capture($event)">
            <div ref="middle" class="middle" id="middleBubbleCapture" @click.capture="capture($event)">
              <div ref="inner" class="inner" id="innerBubbleCapture" @click.capture="capture($event)">
              </div>
            </div>
          </div>
        </div>

          <div class="code">
            <hr>
            <h6>html code</h6>
            <code> <pre>
&lt;div ref="outer" class="outer" id="outerBubbleCapture" @click.capture="capture($event)"&gt;
  &lt;div ref="middle" class="middle" id="middleBubbleCapture" @click.capture="capture($event)"&gt;
    &lt;div ref="inner" class="inner" id="innerBubbleCapture" @click.capture="capture($event)"&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt; </pre> </code>
            <h6>Vue code</h6>
            <code> <pre>
capture(event){
  let two = 0, one = 0, zero = 0;
  for (let i = 2; i &gt;= 0; i--) {
    two === 0 ? two = i : one === 0 ? one = i + 1 : zero = i + 2;
    setTimeout(function() {
      if (!event.path[i].className.includes("-clicked")) {
        event.path[i].className += " " + event.path[i].className +"-clicked";
      }
    }, (two + one + zero)*500);
  }
}
            </pre> </code>
          </div>

          <h5>self</h5>
          <p>
            When you click on the inner box, you will see that there is an <code>alert</code>
            that is triggered only twice. Once for the inner box and once for the
            outer box. That is because the middle box has a <code>.self</code>
            modifier that prevents it from firing at the click event of other nodes.
            Unless the middle box is clicked, the <code>alert</code> will not trigger.
          </p>
          <div class="square">
            <div class="outer" id="outerSelf" @click="self($event)">
              <div class="middle" id="middleSelf" @click.self="self($event)">
                <div class="inner" id="innerSelf" @click="self($event)">
                </div>
              </div>
            </div>
          </div>

          <div class="code">
            <h6>html code</h6>
            <code>
              <pre>&lt;div class="outer" id="outerBubble" @click="self($event)"&gt;
  &lt;div class="middle" id="middleBubble" @click.self="self($event)"&gt;
    &lt;div class="inner" id="innerBubble" @click="self($event)"&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;  </pre>
            </code>
            <h6>Vue code</h6>
            <code><pre>
self(event){
  this.selfClick += 1;
  if(this.selfClick === 3) this.selfClick = 1;
  alert("I clicked the box. This is the alert No " + this.selfClick);
  if (!event.target.className.includes("-clicked")) {
    event.target.className += " " + event.target.className +"-clicked";
  }
}          </pre> </code>
          </div>


    </div>
  </div>

  <script>
  var eventHandling4 = new Vue({
    el: "#eventHandling4",
    data: {
      selfClick: 0
    }, //End of data
    methods: {
      bubble(event){
        for (let i = 1; i < 4; i++) {
          setTimeout(function() {
            if (!event.path[i-1].className.includes("-clicked")) {
              event.path[i-1].className += " " + event.path[i-1].className +"-clicked";
            }
          }, i*1000);
        }
      },
      capture(event){
        let two = 0, one = 0, zero = 0;

        for (let i = 2; i >= 0; i--) {
          two === 0 ? two = i : one === 0 ? one = i + 1 : zero = i + 2;
          setTimeout(function() {
            if (!event.path[i].className.includes("-clicked")) {
              event.path[i].className += " " + event.path[i].className +"-clicked";
            }
          }, (two + one + zero)*500);
        }

      },
      self(event){
        this.selfClick += 1;
        if(this.selfClick === 3) this.selfClick = 1;
        alert("I clicked the box. This is the alert No " + this.selfClick);
        if (!event.target.className.includes("-clicked")) {
          event.target.className += " " + event.target.className +"-clicked";
        }
      }
    } //End of methods
  });

  </script>





  <div id="eventHandling5">
    <h2>Key modifiers</h2>
    <p>
      The <code>v-on</code> listener can also accept key modifiers and click modifiers.
      Hence, we can activate the listeners depending on the keys we set for the
      event listener to be activated, or based on the click events we are doing with
      our mouse.
    </p>
    <p>
      We can identify the different <code>keyCode</code> identifiers by logging
      the <code>event.keyCode</code> events of a <code>keyup</code> or a <code>keydown</code>
      event. For example, the Event Handler <code>@keydown.65="activateMethod"</code>
      is going to activate the method when the key "a" is pressed.
    </p>
    <p>
      Moreover, there are preset key modifiers for which there is no need to know
      the key code. The key modifier aliases are:
      <ul>
        <code>
          <li>.enter</li>
          <li>.tab</li>
          <li>.delete / both for delete and backspace keys</li>
          <li>.esc</li>
          <li>.space</li>
          <li>.up</li>
          <li>.down</li>
          <li>.left</li>
          <li>.right</li>
        </code>
      </ul>
    </p>
    <h3>Automatic Key Modifiers</h3>
    <p>
      Instead of key codes, we can also use valid key names that are exposed during
      the keyboard event by identifying the property of <code>KeyboardEvent.key</code>.
      The only detail is that for event keys that are two words like <code>ArrowDown</code>
      we need to enter the modifier with a kebab-case.
    </p>
    <div class="jumbotron">
      <h4>Example</h4>
      <p>
        Enter in the following input field different keys and see the <code>keyCode</code>
        and the <code>key</code> being displayed on the screen.
      </p>
      <input type="text" name="" value="" @keyup="showEvent">
      <p>
        You pressed the key <b>{{key}}</b> that has a key code <b>{{keyCode}}</b>.
      </p>
    </div>
  </div>


  <script>
    var eventHandling5 = new Vue({
      el: "#eventHandling5",
      data: {
        keyCode: "",
        key: ""
      }, //End of data
      methods: {
        showEvent(){
          this.keyCode = event.keyCode;
          this.key = event.key;
        }
      }
    });
  </script>





  <div id="eventHandling6">
    <h2>System Modifier Keys</h2>
    <p>
      The following modifier keys can be used to trigger keyboard or mouse event
      listeners only when the corresponding modifier keys are pressed.
      <code>
        <li>.ctrl</li>
        <li>.alt</li>
        <li>.shift</li>
        <li>.meta (The Mac home key ⌘ or the windows home key ⊞ etc)</li>
      </code>
    </p>

    <div class="jumbotron">
      <h4>Example</h4>
      <p>
        The following button will trigger the event only if the <code>shift</code>
        key is pressed when clicked.
      </p>
      <button type="button" name="button" @click.shift="modifierClick">shift Click me</button>
      <h6>html code</h6>
      <code>&lt;button type="button" name="button" @click.shift="modifierClick"&gt;shift Click me&lt;/button&gt;</code>
    </div>

    <h3><code>.exact</code> Modifier </h3>
    <p>
      The <code>.exact</code> modifier allows for the exact combination of Modifiers
      to be applied in order to trigger an event.
    </p>
    <div class="jumbotron">
      <h4>Example</h4>
      <p>
        Even though Shift is the modifier, this will fire even if Alt or Ctrl are
        pressed at the same time.
      </p>
      <button type="button" name="button" @click.shift="modifierClick">Shift and any other key and click</button>
      <code>&lt;button type="button" name="button" @click.shift="modifierClick"&gt;shift Click me&lt;/button&gt;</code>
      <p>
        This will only fire when the Shift key is clicked but nothing else.
      </p>
      <button type="button" name="button" @click.shift.exact="modifierClick">Shift and no other key and click</button>
      <code>&lt;button type="button" name="button" @click.shift.exact="modifierClick"&gt;Shift and no other key and click&lt;/button&gt;</code>
      <p>
        This will only fire when no modifier keys are pressed.
      </p>
      <button type="button" name="button" @click.exact="modifierClick">Click with no modifier keys</button>
      <code>&lt;button type="button" name="button" @click.exact="modifierClick"&gt;Click with no modifier keys&lt;/button&gt;</code>
    </div>

    <h3>Mouse Button Modifiers</h3>
    <p>
      These modifiers restrict the handler to events that are triggered only when
      a specific mouse button is clicked.
      <ul>
        <code>
          <li>.left</li>
          <li>.right</li>
          <li>.middle</li>
        </code>
      </ul>
    </p>
  </div>

  <script>
    var eventHandling6 = new Vue({
      el: "#eventHandling6",
      data: {

      }, //End of data
      methods: {
        modifierClick(){
          alert("Sucess!")
        }
      }
    });
  </script>


  <a href="./006-list_rendering.html">Previous - List Rendering</a> <a href="./008-form_input_bindings.html">Next - Form Input Bindings</a>

</body>
</html>
